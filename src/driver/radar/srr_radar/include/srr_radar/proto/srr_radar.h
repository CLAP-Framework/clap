// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: srr_radar.proto
#ifndef PROTO_SRR_RADAR_H
#define PROTO_SRR_RADAR_H

#include <cstring>
#include <cstdint>
#include <limits>
#include <string>
#include <vector>
#include <array>

namespace drivers {

class ClusterListStatus_70B;
class RadarState_60A;
class SrrRadar;
class SrrRadarObs;
class TrackListStatus_60B;
namespace srr_radar {
enum {
  Radar_Config = 0x200,  
  Coll_Det_Config = 0x400,
  Coll_Det_State = 0x408,
  Coll_Det_Warn = 0x409,
  Radar_State = 0x60A,  
  Track_List_Status = 0x60B,  
  Track_1 = 0x60C, 
  Track_2 = 0x60D, 
  Cluster_List_Status = 0x70B,
  Cluster_1 = 0x70C,
};
} // namespace srr_radar
}  // namespace drivers

// ===================================================================
namespace drivers {

class RadarState_60A {
 public:
  RadarState_60A();
  virtual ~RadarState_60A();

  RadarState_60A(const RadarState_60A& from);

  inline RadarState_60A& operator=(const RadarState_60A& from) {
    has_bits_ = from.has_bits_;
    actl_mode_ = from.actl_mode_;
    radar_cfg_status_ = from.radar_cfg_status_;
    radarst_rollcount_= from.radarst_rollcount_;
    return *this;
  }

  public:
  // optional uint32_t actl_mode = 1;
  bool has_actl_mode() const;
  void clear_actl_mode();
  uint32_t actl_mode() const;
  void set_actl_mode(uint32_t value);

  // optional uint32_t radar_cfg_status = 2;
  bool has_radar_cfg_status() const;
  void clear_radar_cfg_status();
  uint32_t radar_cfg_status() const;
  void set_radar_cfg_status(uint32_t value);

  // optional uint32_t radarst_rollcount = 3;
  bool has_radarst_rollcount() const;
  void clear_radarst_rollcount();
  uint32_t radarst_rollcount() const;
  void set_radarst_rollcount(uint32_t value);

 private:

  uint32_t has_bits_;
  uint32_t actl_mode_;
  uint32_t radar_cfg_status_;
  uint32_t radarst_rollcount_;
};
// -------------------------------------------------------------------

class TrackListStatus_60B{
 public:
  TrackListStatus_60B();
  virtual ~TrackListStatus_60B();

  TrackListStatus_60B(const TrackListStatus_60B& from);

  inline TrackListStatus_60B& operator=(const TrackListStatus_60B& from) {
    has_bits_ = from.has_bits_;
    num_of_tracks_ = from.num_of_tracks_;
    trackst_rollcount_ = from.trackst_rollcount_;
    return *this;
  }
  public:
  // optional int32_t num_of_tracks = 1 [default = 0];
  bool has_num_of_tracks() const;
  void clear_num_of_tracks();
  int32_t num_of_tracks() const;
  void set_num_of_tracks(int32_t value);

  // optional int32_t trackst_rollcount = 2 [default = 0];
  bool has_trackst_rollcount() const;
  void clear_trackst_rollcount();
  int32_t trackst_rollcount() const;
  void set_trackst_rollcount(int32_t value);

 private:

  uint32_t has_bits_;
  int32_t num_of_tracks_;
  int32_t trackst_rollcount_;
};
// -------------------------------------------------------------------

class ClusterListStatus_70B{
 public:
  ClusterListStatus_70B();
  virtual ~ClusterListStatus_70B();

  ClusterListStatus_70B(const ClusterListStatus_70B& from);

  inline ClusterListStatus_70B& operator=(const ClusterListStatus_70B& from) {
    has_bits_ = from.has_bits_;
    num_of_cluster_ = from.num_of_cluster_;
    clusterst_rollcount_ = from.clusterst_rollcount_;
    return *this;
  }
  public:
  // optional int32_t num_of_cluster = 1 [default = 0];
  bool has_num_of_cluster() const;
  void clear_num_of_cluster();
  int32_t num_of_cluster() const;
  void set_num_of_cluster(int32_t value);

  // optional int32_t clusterst_rollcount = 2 [default = 0];
  bool has_clusterst_rollcount() const;
  void clear_clusterst_rollcount();
  int32_t clusterst_rollcount() const;
  void set_clusterst_rollcount(int32_t value);

 private:

  uint32_t has_bits_;
  int32_t num_of_cluster_;
  int32_t clusterst_rollcount_;  
};
// -------------------------------------------------------------------

class SrrRadarObs{
 public:
  SrrRadarObs();
  virtual ~SrrRadarObs();

  SrrRadarObs(const SrrRadarObs& from);

  inline SrrRadarObs& operator=(const SrrRadarObs& from) {
    has_bits_ = from.has_bits_;
    clusterortrack_ = from.clusterortrack_;
    obstacle_id_ = from.obstacle_id_;
    cluster_index_ = from.cluster_index_;
    cluster1_rollcount_ = from.cluster1_rollcount_;
    rcs_value_ = from.rcs_value_;
    range_ = from.range_;
    vrel_ = from.vrel_;
    azimuth_ = from.azimuth_;
    track_id_ = from.track_id_;   //NOT_USED
    track_longitude_displ_ = from.track_longitude_displ_;
    track_lateral_displ_ = from.track_lateral_displ_;
    track_longitude_vel_ = from.track_longitude_vel_;
    track_index_ = from.track_index_;
    track1_rollcount_ = from.track1_rollcount_;
    track_lateral_vel_ = from.track_lateral_vel_;
    track_rcsvalue_ = from.track_rcsvalue_;   //replaced by rcs_value_
    track_lifetime_ = from.track_lifetime_;
    track2_index_ = from.track2_index_;
    track2_rollcount_ = from.track2_rollcount_;
    return *this;
  }

  public:
  // optional uint64 header = 1;

  // optional bool clusterortrack = 2;
  bool has_clusterortrack() const;
  void clear_clusterortrack();
  bool clusterortrack() const;
  void set_clusterortrack(bool value);

  // optional int32_t obstacle_id = 3;
  bool has_obstacle_id() const;
  void clear_obstacle_id();
  int32_t obstacle_id() const;
  void set_obstacle_id(int32_t value);

  // optional int32_t cluster_index = 4;
  bool has_cluster_index() const;
  void clear_cluster_index();
  int32_t cluster_index() const;
  void set_cluster_index(int32_t value);

  // optional int32_t cluster1_rollcount = 5;
  bool has_cluster1_rollcount() const;
  void clear_cluster1_rollcount();
  int32_t cluster1_rollcount() const;
  void set_cluster1_rollcount(int32_t value);

  // optional double rcs_value = 6;
  bool has_rcs_value() const;
  void clear_rcs_value();
  double rcs_value() const;
  void set_rcs_value(double value);

  // optional double range = 7;
  bool has_range() const;
  void clear_range();
  double range() const;
  void set_range(double value);

  // optional int32_t azimuth = 8;
  bool has_azimuth() const;
  void clear_azimuth();
  int32_t azimuth() const;
  void set_azimuth(int32_t value);

  // optional double vrel = 9;
  bool has_vrel() const;
  void clear_vrel();
  double vrel() const;
  void set_vrel(double value);

  // optional int32_t track_id = 10;
  bool has_track_id() const;
  void clear_track_id();
  int32_t track_id() const;
  void set_track_id(int32_t value);

  // optional double track_longitude_displ = 11;
  bool has_track_longitude_displ() const;
  void clear_track_longitude_displ();
  double track_longitude_displ() const;
  void set_track_longitude_displ(double value);

  // optional double track_lateral_displ = 12;
  bool has_track_lateral_displ() const;
  void clear_track_lateral_displ();
  double track_lateral_displ() const;
  void set_track_lateral_displ(double value);

  // optional int32_t track_index = 13;
  bool has_track_index() const;
  void clear_track_index();
  int32_t track_index() const;
  void set_track_index(int32_t value);

  // optional double track_longitude_vel = 14;
  bool has_track_longitude_vel() const;
  void clear_track_longitude_vel();
  double track_longitude_vel() const;
  void set_track_longitude_vel(double value);

  // optional double track_lateral_vel = 15;
  bool has_track_lateral_vel() const;
  void clear_track_lateral_vel();
  double track_lateral_vel() const;
  void set_track_lateral_vel(double value);

  // optional int32_t track1_rollcount = 16;
  bool has_track1_rollcount() const;
  void clear_track1_rollcount();
  int32_t track1_rollcount() const;
  void set_track1_rollcount(int32_t value);

  // optional double track_rcsvalue = 17;
  bool has_track_rcsvalue() const;
  void clear_track_rcsvalue();
  double track_rcsvalue() const;
  void set_track_rcsvalue(double value);

  // optional double track_lifetime = 18;
  bool has_track_lifetime() const;
  void clear_track_lifetime();
  double track_lifetime() const;
  void set_track_lifetime(double value);

  // optional int32_t track2_index = 19;
  bool has_track2_index() const;
  void clear_track2_index();
  int32_t track2_index() const;
  void set_track2_index(int32_t value);

  // optional int32_t track2_rollcount = 20;
  bool has_track2_rollcount() const;
  void clear_track2_rollcount();
  int32_t track2_rollcount() const;
  void set_track2_rollcount(int32_t value);

  // @@protoc_insertion_point(class_scope:drivers.SrrRadarObs)
 private:
  uint32_t has_bits_;
  bool clusterortrack_;
  int32_t obstacle_id_;
  int32_t cluster_index_;
  int32_t cluster1_rollcount_;
  double rcs_value_;
  double range_;
  double vrel_;
  int32_t azimuth_;
  int32_t track_id_;
  double track_longitude_displ_;
  double track_lateral_displ_;
  double track_longitude_vel_;
  int32_t track_index_;
  int32_t track1_rollcount_;
  double track_lateral_vel_;
  double track_rcsvalue_;
  double track_lifetime_;
  int32_t track2_index_;
  int32_t track2_rollcount_;
};
// -------------------------------------------------------------------

class SrrRadar{
 public:
  SrrRadar();
  virtual ~SrrRadar();

  SrrRadar(const SrrRadar& from);

  inline SrrRadar& operator=(const SrrRadar& from) {
    has_bits_ = from.has_bits_;
      srrobs_.clear();
      srrobs_.insert(srrobs_.begin(), from.srrobs_.cbegin(), from.srrobs_.cend());
      if(from.radar_state_ == nullptr ) {
        radar_state_ = nullptr;
      } else {
        radar_state_ = new drivers::RadarState_60A(*from.radar_state_);
      }
      if(from.track_list_status_ == nullptr ) {
        track_list_status_ = nullptr;
      } else {
        track_list_status_ = new drivers::TrackListStatus_60B(*from.track_list_status_);
      }
      if(from.cluster_list_status_ == nullptr ) {
        cluster_list_status_ = nullptr;
      } else {
        cluster_list_status_ = new drivers::ClusterListStatus_70B(*from.cluster_list_status_);
      }
      return *this;
  }
  public:
  // optional uint64 header = 1;

  // repeated .drivers.SrrRadarObs srrobs = 2;
  int srrobs_size() const;
  void clear_srrobs();
  ::std::vector< ::drivers::SrrRadarObs >* mutable_srrobs();
  ::drivers::SrrRadarObs* mutable_srrobs(int index);
  const ::drivers::SrrRadarObs& srrobs(int index) const;
  ::drivers::SrrRadarObs* add_srrobs();
  const std::vector< ::drivers::SrrRadarObs >& srrobs() const;

  // optional .drivers.RadarState_60A radar_state = 3;
  bool has_radar_state() const;
  void clear_radar_state();
  const ::drivers::RadarState_60A& radar_state() const;
  ::drivers::RadarState_60A* mutable_radar_state();
  ::drivers::RadarState_60A* release_radar_state();
  void set_allocated_radar_state(::drivers::RadarState_60A* radar_state);

  // optional .drivers.TrackListStatus_60B track_list_status = 4;
  bool has_track_list_status() const;
  void clear_track_list_status();
  const ::drivers::TrackListStatus_60B& track_list_status() const;
  ::drivers::TrackListStatus_60B* mutable_track_list_status();
  ::drivers::TrackListStatus_60B* release_track_list_status();
  void set_allocated_track_list_status(::drivers::TrackListStatus_60B* track_list_status);

  // optional .drivers.ClusterListStatus_70B cluster_list_status = 5;
  bool has_cluster_list_status() const;
  void clear_cluster_list_status();
  const ::drivers::ClusterListStatus_70B& cluster_list_status() const;
  ::drivers::ClusterListStatus_70B* mutable_cluster_list_status();
  ::drivers::ClusterListStatus_70B* release_cluster_list_status();
  void set_allocated_cluster_list_status(::drivers::ClusterListStatus_70B* cluster_list_status);

 private:
  uint32_t has_bits_;
  std::vector< ::drivers::SrrRadarObs > srrobs_;
  ::drivers::RadarState_60A* radar_state_;
  ::drivers::TrackListStatus_60B* track_list_status_;
  ::drivers::ClusterListStatus_70B* cluster_list_status_;
};
// ===================================================================
}  // namespace drivers

#endif  // PROTO_SRR_RADAR_H
