// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: srr_radar.proto

#include <cstring>
#include <cstdint>
#include <limits>
#include <string>
#include <vector>
#include <array>
#include <algorithm>
//#include "srr_radar.pb.h"
#include "srr_radar/proto/srr_radar.h"


namespace drivers {
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__


// RadarState_60A
RadarState_60A::RadarState_60A() :
      has_bits_(0),
      actl_mode_(0),
      radar_cfg_status_(0),
      radarst_rollcount_(0)
{}

RadarState_60A::~RadarState_60A() 
{}

RadarState_60A::RadarState_60A(const RadarState_60A& from):
      has_bits_(from.has_bits_),
      actl_mode_(from.actl_mode_),
      radar_cfg_status_(from.radar_cfg_status_),
      radarst_rollcount_(from.radar_cfg_status_)
{}

// optional uint32_t actl_mode = 1;
bool RadarState_60A::has_actl_mode() const {
  return (has_bits_ & 0x00000001u) != 0;
}
void RadarState_60A::clear_actl_mode() {
  actl_mode_ = 0u;
  has_bits_ &= ~0x00000001u;
}
uint32_t RadarState_60A::actl_mode() const {
  return actl_mode_;
}
 void RadarState_60A::set_actl_mode(uint32_t value) {
  has_bits_ |= 0x00000001u;
  actl_mode_ = value;
}

// optional uint32_t radar_cfg_status = 2;
bool RadarState_60A::has_radar_cfg_status() const {
  return (has_bits_ & 0x00000002u) != 0;
}
void RadarState_60A::clear_radar_cfg_status() {
  radar_cfg_status_ = 0u;
  has_bits_ &= ~0x00000002u;
}
uint32_t RadarState_60A::radar_cfg_status() const {
  return radar_cfg_status_;
}
 void RadarState_60A::set_radar_cfg_status(uint32_t value) {
  has_bits_ |= 0x00000002u;
  radar_cfg_status_ = value;
}

// optional uint32_t radarst_rollcount = 3;
bool RadarState_60A::has_radarst_rollcount() const {
  return (has_bits_ & 0x00000004u) != 0;
}
 void RadarState_60A::clear_radarst_rollcount() {
  radarst_rollcount_ = 0u;
  has_bits_ &= ~0x00000004u;
}
 uint32_t RadarState_60A::radarst_rollcount() const {
  return radarst_rollcount_;
}
 void RadarState_60A::set_radarst_rollcount(uint32_t value) {
  has_bits_ |= 0x00000004u;
  radarst_rollcount_ = value;
}

//TrackListStatus_60B
TrackListStatus_60B::TrackListStatus_60B():
      has_bits_(0),
      num_of_tracks_(0),
      trackst_rollcount_(0)
{}

TrackListStatus_60B::TrackListStatus_60B(const TrackListStatus_60B& from):
      has_bits_(from.has_bits_),
      num_of_tracks_(from.num_of_tracks_),
      trackst_rollcount_(from.trackst_rollcount_)
{}

TrackListStatus_60B::~TrackListStatus_60B() 
{}

// optional int32_t num_of_tracks = 1 [default = 0];
bool TrackListStatus_60B::has_num_of_tracks() const {
  return (has_bits_ & 0x00000001u) != 0;
}
void TrackListStatus_60B::clear_num_of_tracks() {
  num_of_tracks_ = 0;
  has_bits_ &= ~0x00000001u;
}
int32_t TrackListStatus_60B::num_of_tracks() const {
  return num_of_tracks_;
}
 void TrackListStatus_60B::set_num_of_tracks(int32_t value) {
  has_bits_ |= 0x00000001u;
  num_of_tracks_ = value;
}

// optional int32_t trackst_rollcount = 2 [default = 0];
bool TrackListStatus_60B::has_trackst_rollcount() const {
  return (has_bits_ & 0x00000002u) != 0;
}
void TrackListStatus_60B::clear_trackst_rollcount() {
  trackst_rollcount_ = 0;
  has_bits_ &= ~0x00000002u;
}
int32_t TrackListStatus_60B::trackst_rollcount() const {
  return trackst_rollcount_;
}
 void TrackListStatus_60B::set_trackst_rollcount(int32_t value) {
  has_bits_ |= 0x00000002u;
  trackst_rollcount_ = value;
}

// ===================================================================
// ClusterListStatus_70B
ClusterListStatus_70B::ClusterListStatus_70B():
      has_bits_(0),
      num_of_cluster_(0),
      clusterst_rollcount_(0)
{}

ClusterListStatus_70B::ClusterListStatus_70B(const ClusterListStatus_70B& from):
      has_bits_(from.has_bits_),
      num_of_cluster_(from.num_of_cluster_),
      clusterst_rollcount_(from.clusterst_rollcount_)
{}


ClusterListStatus_70B::~ClusterListStatus_70B() {}


// optional int32_t num_of_cluster = 1 [default = 0];
bool ClusterListStatus_70B::has_num_of_cluster() const {
  return (has_bits_ & 0x00000001u) != 0;
}
void ClusterListStatus_70B::clear_num_of_cluster() {
  num_of_cluster_ = 0;
  has_bits_ &= ~0x00000001u;
}
  int32_t ClusterListStatus_70B::num_of_cluster() const {
  return num_of_cluster_;
}
 void ClusterListStatus_70B::set_num_of_cluster(int32_t value) {
  has_bits_ |= 0x00000001u;
  num_of_cluster_ = value;
}

// optional int32_t clusterst_rollcount = 2 [default = 0];
bool ClusterListStatus_70B::has_clusterst_rollcount() const {
  return (has_bits_ & 0x00000002u) != 0;
}
void ClusterListStatus_70B::clear_clusterst_rollcount() {
  clusterst_rollcount_ = 0;
  has_bits_ &= ~0x00000002u;
}
  int32_t ClusterListStatus_70B::clusterst_rollcount() const {
  return clusterst_rollcount_;
}
 void ClusterListStatus_70B::set_clusterst_rollcount(int32_t value) {
  has_bits_ |= 0x00000002u;
  clusterst_rollcount_ = value;
}

// ===================================================================
// SrrRadarObs
SrrRadarObs::SrrRadarObs():
      has_bits_(0),
      clusterortrack_(0),
      obstacle_id_(0),
      cluster_index_(0),
      cluster1_rollcount_(0),
      rcs_value_(0),
      range_(0),
      azimuth_(0),
      vrel_(0),
      track_id_(0),
      track_longitude_displ_(0),
      track_lateral_displ_(0),
      track_index_(0),
      track_longitude_vel_(0),
      track_lateral_vel_(0),
      track1_rollcount_(0),
      track_rcsvalue_(0),
      track_lifetime_(0),
      track2_index_(0),
      track2_rollcount_(0)
{}

SrrRadarObs::SrrRadarObs(const SrrRadarObs& from):
      has_bits_(from.has_bits_),
      clusterortrack_(from.clusterortrack_),
      obstacle_id_(from.obstacle_id_),
      cluster_index_(from.cluster_index_),
      cluster1_rollcount_(from.cluster1_rollcount_),
      rcs_value_(from.rcs_value_),
      range_(from.range_),
      azimuth_(from.azimuth_),
      vrel_(from.vrel_),
      track_id_(from.track_id_),
      track_longitude_displ_(from.track_longitude_displ_),
      track_lateral_displ_(from.track_lateral_displ_),
      track_index_(from.track_index_),
      track_longitude_vel_(from.track_longitude_vel_),
      track_lateral_vel_(from.track_lateral_vel_),
      track1_rollcount_(from.track1_rollcount_),
      track_rcsvalue_(from.track_rcsvalue_),
      track_lifetime_(from.track_lifetime_),
      track2_index_(from.track2_index_),
      track2_rollcount_(from.track2_rollcount_)
{}

SrrRadarObs::~SrrRadarObs() 
{}

// optional uint64 header = 1;
// optional bool clusterortrack = 2;
bool SrrRadarObs::has_clusterortrack() const {
  return (has_bits_ & 0x00000002u) != 0;
}
void SrrRadarObs::clear_clusterortrack() {
  clusterortrack_ = false;
  has_bits_ &= ~0x00000002u;
}
 bool SrrRadarObs::clusterortrack() const {
  return clusterortrack_;
}
 void SrrRadarObs::set_clusterortrack(bool value) {
  has_bits_ |= 0x00000002u;
  clusterortrack_ = value;
}

// optional int32_t obstacle_id = 3;
bool SrrRadarObs::has_obstacle_id() const {
  return (has_bits_ & 0x00000004u) != 0;
}
void SrrRadarObs::clear_obstacle_id() {
  obstacle_id_ = 0;
  has_bits_ &= ~0x00000004u;
}
  int32_t SrrRadarObs::obstacle_id() const {
  return obstacle_id_;
}
 void SrrRadarObs::set_obstacle_id(int32_t value) {
  has_bits_ |= 0x00000004u;
  obstacle_id_ = value;
}

// optional int32_t cluster_index = 4;
bool SrrRadarObs::has_cluster_index() const {
  return (has_bits_ & 0x00000008u) != 0;
}
void SrrRadarObs::clear_cluster_index() {
  cluster_index_ = 0;
  has_bits_ &= ~0x00000008u;
}
  int32_t SrrRadarObs::cluster_index() const {
  return cluster_index_;
}
 void SrrRadarObs::set_cluster_index(int32_t value) {
  has_bits_ |= 0x00000008u;
  cluster_index_ = value;
}

// optional int32_t cluster1_rollcount = 5;
bool SrrRadarObs::has_cluster1_rollcount() const {
  return (has_bits_ & 0x00000010u) != 0;
}
void SrrRadarObs::clear_cluster1_rollcount() {
  cluster1_rollcount_ = 0;
  has_bits_ &= ~0x00000010u;
}
  int32_t SrrRadarObs::cluster1_rollcount() const {
  return cluster1_rollcount_;
}
 void SrrRadarObs::set_cluster1_rollcount(int32_t value) {
  has_bits_ |= 0x00000010u;
  cluster1_rollcount_ = value;
}

// optional double rcs_value = 6;
bool SrrRadarObs::has_rcs_value() const {
  return (has_bits_ & 0x00000020u) != 0;
}
void SrrRadarObs::clear_rcs_value() {
  rcs_value_ = 0;
  has_bits_ &= ~0x00000020u;
}
 double SrrRadarObs::rcs_value() const {
  return rcs_value_;
}
 void SrrRadarObs::set_rcs_value(double value) {
  has_bits_ |= 0x00000020u;
  rcs_value_ = value;
}

// optional double range = 7;
bool SrrRadarObs::has_range() const {
  return (has_bits_ & 0x00000040u) != 0;
}
void SrrRadarObs::clear_range() {
  range_ = 0;
  has_bits_ &= ~0x00000040u;
}
 double SrrRadarObs::range() const {
  return range_;
}
 void SrrRadarObs::set_range(double value) {
  has_bits_ |= 0x00000040u;
  range_ = value;
}

// optional int32_t azimuth = 8;
bool SrrRadarObs::has_azimuth() const {
  return (has_bits_ & 0x00000080u) != 0;
}
void SrrRadarObs::clear_azimuth() {
  azimuth_ = 0;
  has_bits_ &= ~0x00000080u;
}
  int32_t SrrRadarObs::azimuth() const {
  return azimuth_;
}
 void SrrRadarObs::set_azimuth(int32_t value) {
  has_bits_ |= 0x00000080u;
  azimuth_ = value;
}

// optional double vrel = 9;
bool SrrRadarObs::has_vrel() const {
  return (has_bits_ & 0x00000100u) != 0;
}
void SrrRadarObs::clear_vrel() {
  vrel_ = 0;
  has_bits_ &= ~0x00000100u;
}
 double SrrRadarObs::vrel() const {
  return vrel_;
}
 void SrrRadarObs::set_vrel(double value) {
  has_bits_ |= 0x00000100u;
  vrel_ = value;
}

// optional int32_t track_id = 10;
bool SrrRadarObs::has_track_id() const {
  return (has_bits_ & 0x00000200u) != 0;
}
void SrrRadarObs::clear_track_id() {
  track_id_ = 0;
  has_bits_ &= ~0x00000200u;
}
  int32_t SrrRadarObs::track_id() const {
  return track_id_;
}
 void SrrRadarObs::set_track_id(int32_t value) {
  has_bits_ |= 0x00000200u;
  track_id_ = value;
}

// optional double track_longitude_displ = 11;
bool SrrRadarObs::has_track_longitude_displ() const {
  return (has_bits_ & 0x00000400u) != 0;
}
void SrrRadarObs::clear_track_longitude_displ() {
  track_longitude_displ_ = 0;
  has_bits_ &= ~0x00000400u;
}
 double SrrRadarObs::track_longitude_displ() const {
  return track_longitude_displ_;
}
 void SrrRadarObs::set_track_longitude_displ(double value) {
  has_bits_ |= 0x00000400u;
  track_longitude_displ_ = value;
}

// optional double track_lateral_displ = 12;
bool SrrRadarObs::has_track_lateral_displ() const {
  return (has_bits_ & 0x00000800u) != 0;
}
void SrrRadarObs::clear_track_lateral_displ() {
  track_lateral_displ_ = 0;
  has_bits_ &= ~0x00000800u;
}
 double SrrRadarObs::track_lateral_displ() const {
  return track_lateral_displ_;
}
 void SrrRadarObs::set_track_lateral_displ(double value) {
  has_bits_ |= 0x00000800u;
  track_lateral_displ_ = value;
}

// optional int32_t track_index = 13;
bool SrrRadarObs::has_track_index() const {
  return (has_bits_ & 0x00001000u) != 0;
}
void SrrRadarObs::clear_track_index() {
  track_index_ = 0;
  has_bits_ &= ~0x00001000u;
}
  int32_t SrrRadarObs::track_index() const {
  return track_index_;
}
 void SrrRadarObs::set_track_index(int32_t value) {
  has_bits_ |= 0x00001000u;
  track_index_ = value;
}

// optional double track_longitude_vel = 14;
bool SrrRadarObs::has_track_longitude_vel() const {
  return (has_bits_ & 0x00002000u) != 0;
}
void SrrRadarObs::clear_track_longitude_vel() {
  track_longitude_vel_ = 0;
  has_bits_ &= ~0x00002000u;
}
 double SrrRadarObs::track_longitude_vel() const {
  return track_longitude_vel_;
}
 void SrrRadarObs::set_track_longitude_vel(double value) {
  has_bits_ |= 0x00002000u;
  track_longitude_vel_ = value;
}

// optional double track_lateral_vel = 15;
bool SrrRadarObs::has_track_lateral_vel() const {
  return (has_bits_ & 0x00004000u) != 0;
}
void SrrRadarObs::clear_track_lateral_vel() {
  track_lateral_vel_ = 0;
  has_bits_ &= ~0x00004000u;
}
 double SrrRadarObs::track_lateral_vel() const {
  return track_lateral_vel_;
}
 void SrrRadarObs::set_track_lateral_vel(double value) {
  has_bits_ |= 0x00004000u;
  track_lateral_vel_ = value;
}

// optional int32_t track1_rollcount = 16;
bool SrrRadarObs::has_track1_rollcount() const {
  return (has_bits_ & 0x00008000u) != 0;
}
void SrrRadarObs::clear_track1_rollcount() {
  track1_rollcount_ = 0;
  has_bits_ &= ~0x00008000u;
}
  int32_t SrrRadarObs::track1_rollcount() const {
  return track1_rollcount_;
}
 void SrrRadarObs::set_track1_rollcount(int32_t value) {
  has_bits_ |= 0x00008000u;
  track1_rollcount_ = value;
}

// optional double track_rcsvalue = 17;
bool SrrRadarObs::has_track_rcsvalue() const {
  return (has_bits_ & 0x00010000u) != 0;
}
void SrrRadarObs::clear_track_rcsvalue() {
  track_rcsvalue_ = 0;
  has_bits_ &= ~0x00010000u;
}
 double SrrRadarObs::track_rcsvalue() const {
  return track_rcsvalue_;
}
 void SrrRadarObs::set_track_rcsvalue(double value) {
  has_bits_ |= 0x00010000u;
  track_rcsvalue_ = value;
}

// optional double track_lifetime = 18;
bool SrrRadarObs::has_track_lifetime() const {
  return (has_bits_ & 0x00020000u) != 0;
}
void SrrRadarObs::clear_track_lifetime() {
  track_lifetime_ = 0;
  has_bits_ &= ~0x00020000u;
}
 double SrrRadarObs::track_lifetime() const {
  return track_lifetime_;
}
 void SrrRadarObs::set_track_lifetime(double value) {
  has_bits_ |= 0x00020000u;
  track_lifetime_ = value;
}

// optional int32_t track2_index = 19;
bool SrrRadarObs::has_track2_index() const {
  return (has_bits_ & 0x00040000u) != 0;
}
void SrrRadarObs::clear_track2_index() {
  track2_index_ = 0;
  has_bits_ &= ~0x00040000u;
}
  int32_t SrrRadarObs::track2_index() const {
  return track2_index_;
}
 void SrrRadarObs::set_track2_index(int32_t value) {
  has_bits_ |= 0x00040000u;
  track2_index_ = value;
}

// optional int32_t track2_rollcount = 20;
bool SrrRadarObs::has_track2_rollcount() const {
  return (has_bits_ & 0x00080000u) != 0;
}
void SrrRadarObs::clear_track2_rollcount() {
  track2_rollcount_ = 0;
  has_bits_ &= ~0x00080000u;
}
  int32_t SrrRadarObs::track2_rollcount() const {
  return track2_rollcount_;
}
 void SrrRadarObs::set_track2_rollcount(int32_t value) {
  has_bits_ |= 0x00080000u;
  track2_rollcount_ = value;
}

// ===================================================================
// SrrRadar
SrrRadar::SrrRadar() :
      has_bits_(0),
      radar_state_(0),
      track_list_status_(0),
      cluster_list_status_(0)
{}

SrrRadar::SrrRadar(const SrrRadar& from):
      has_bits_(from.has_bits_),
      radar_state_(from.radar_state_),
      track_list_status_(from.track_list_status_),
      cluster_list_status_(from.cluster_list_status_)
{}

SrrRadar::~SrrRadar() 
{}

// optional uint64 header = 1;

// repeated .drivers.SrrRadarObs srrobs = 2;
int SrrRadar::srrobs_size() const {
  return srrobs_.size();
}
void SrrRadar::clear_srrobs() {
  srrobs_.clear();
}
::drivers::SrrRadarObs* SrrRadar::mutable_srrobs(int index) {
  return &srrobs_.at(index);
}
std::vector< ::drivers::SrrRadarObs >* SrrRadar::mutable_srrobs() {
  return &srrobs_;
}
const ::drivers::SrrRadarObs& SrrRadar::srrobs(int index) const {
  return srrobs_.at(index);
}
::drivers::SrrRadarObs* SrrRadar::add_srrobs() {
  srrobs_.push_back(drivers::SrrRadarObs());
  return &srrobs_.at(srrobs_.size()-1);
}
const std::vector< ::drivers::SrrRadarObs >&
SrrRadar::srrobs() const {
  return srrobs_;
}

// optional .drivers.RadarState_60A radar_state = 3;
bool SrrRadar::has_radar_state() const {
  return (has_bits_ & 0x00000004u) != 0;
}
void SrrRadar::clear_radar_state() {
  if (radar_state_ != nullptr) delete radar_state_;
  has_bits_ &= ~0x00000004u;
}
const ::drivers::RadarState_60A& SrrRadar::radar_state() const {
  const drivers::RadarState_60A* p = radar_state_;
  return *p;
}
::drivers::RadarState_60A* SrrRadar::release_radar_state() {
  has_bits_ &= ~0x00000004u;
  ::drivers::RadarState_60A* temp = radar_state_;
  radar_state_ = NULL;
  return temp;
}
::drivers::RadarState_60A* SrrRadar::mutable_radar_state() {
  has_bits_ |= 0x00000004u;
  if (radar_state_ == NULL) {
    radar_state_ = new ::drivers::RadarState_60A;
  }
  return radar_state_;
}
void SrrRadar::set_allocated_radar_state(::drivers::RadarState_60A* radar_state) {
  if (radar_state_!= nullptr) {
    delete radar_state_;
  }  
  radar_state_ = radar_state;
  if (radar_state) {
    has_bits_ |= 0x00000004u;
  } else {
    has_bits_ &= ~0x00000004u;
  }
}

// optional .drivers.TrackListStatus_60B track_list_status = 4;
bool SrrRadar::has_track_list_status() const {
  return (has_bits_ & 0x00000008u) != 0;
}
void SrrRadar::clear_track_list_status() {
  if (track_list_status_ != nullptr) delete track_list_status_;
  has_bits_ &= ~0x00000008u;
}
const ::drivers::TrackListStatus_60B& SrrRadar::track_list_status() const {
  const drivers::TrackListStatus_60B* p = track_list_status_;
  return *p;
}
::drivers::TrackListStatus_60B* SrrRadar::release_track_list_status() {
  has_bits_ &= ~0x00000008u;
  ::drivers::TrackListStatus_60B* temp = track_list_status_;
  track_list_status_ = NULL;
  return temp;
}
::drivers::TrackListStatus_60B* SrrRadar::mutable_track_list_status() {
  has_bits_ |= 0x00000008u;
  if (track_list_status_ == NULL) {
    track_list_status_ = new ::drivers::TrackListStatus_60B;
  }
  return track_list_status_;
}
void SrrRadar::set_allocated_track_list_status(::drivers::TrackListStatus_60B* track_list_status) {
  if (track_list_status_!= nullptr) {
    delete track_list_status_;
  }    
  track_list_status_ = track_list_status;
  if (track_list_status) {
    has_bits_ |= 0x00000008u;
  } else {
    has_bits_ &= ~0x00000008u;
  }
}

// optional .drivers.ClusterListStatus_70B cluster_list_status = 5;
bool SrrRadar::has_cluster_list_status() const {
  return (has_bits_ & 0x00000010u) != 0;
}
void SrrRadar::clear_cluster_list_status() {
  if (cluster_list_status_ != nullptr) delete cluster_list_status_;
  has_bits_ &= ~0x00000010u;
}
const ::drivers::ClusterListStatus_70B& SrrRadar::cluster_list_status() const {
  const drivers::ClusterListStatus_70B* p = cluster_list_status_;
  return *p;
}
::drivers::ClusterListStatus_70B* SrrRadar::release_cluster_list_status() {
  has_bits_ &= ~0x00000010u;
  ::drivers::ClusterListStatus_70B* temp = cluster_list_status_;
  cluster_list_status_ = NULL;
  return temp;
}
::drivers::ClusterListStatus_70B* SrrRadar::mutable_cluster_list_status() {
  has_bits_ |= 0x00000010u;
  if (cluster_list_status_ == NULL) {
    cluster_list_status_ = new ::drivers::ClusterListStatus_70B;
  }
  return cluster_list_status_;
}
void SrrRadar::set_allocated_cluster_list_status(::drivers::ClusterListStatus_70B* cluster_list_status) {
  if (cluster_list_status_!= nullptr) {
    delete cluster_list_status_;
  }  
  cluster_list_status_ = cluster_list_status;
  if (cluster_list_status) {
    has_bits_ |= 0x00000010u;
  } else {
    has_bits_ &= ~0x00000010u;
  }
}
}  // namespace drivers
// @@protoc_insertion_point(global_scope)
