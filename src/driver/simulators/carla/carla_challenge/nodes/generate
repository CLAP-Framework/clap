#!/usr/bin/env python

import sys
import rospy

import numpy as np
from zzz_navigation_msgs.msg import MapString, Map, Lane, LanePoint
from nav_msgs.msg import Path
from zzz_driver_msgs.msg import RigidBodyStateStamped
from carla_reference_path_generator import CarlaReferecePathGenerator

import carla
import random
import time
import thread

RUNNING_TIME = 300

###########
# Event 4 Environment Setting
###########

def spawn_traffic_circle_agents(max_agents, world, blueprints, spawn_points, verbose=False):
    '''
    Continuously spawns agents around the traffic circle in Town03.

    Parameters
    ----------
    max_agents : int
        The maximum number of agents allowed in the scenario at any given time.
    actors : list
        A list of actors that have been spawned into the Carla world
    world : carla.World
        The Carla world in which to spawn actors.
    verbose : bool, optional
        Used to determine whether some information should be displayed.
    '''

    sp_indices = [
        8, 9, 47, 48, 55, 56, 57, 58, 145, 146, 153, 154, 164, 182, 183
        # 0, 7, 8, 112, 113, 114, 118, 120, 121, 122, 123, 146, 149, 210, 211,218,219, 229, 247, 248, 257
    ]

    actor_list = world.get_actors()
    vehicle_list = actor_list.filter("*vehicle*")
    num_agents = len(vehicle_list)

    if num_agents < max_agents:
        blueprint = random.choice(blueprints)
        blueprint.set_attribute('role_name', 'autopilot')

        spawn_point = spawn_points[random.choice(sp_indices)]
        min_d = 100
        for vehicle in vehicle_list:
            d = vehicle.get_location().distance(spawn_point.location)
            if d < min_d:
                min_d = d
        if min_d > 20:
            new_vehicle = world.try_spawn_actor(blueprint, spawn_point)
            if new_vehicle:
                if "vehicle" in new_vehicle.type_id:
                    new_vehicle.set_autopilot(True)


def remove_non_traffic_circle_agents(world, verbose=False):
    '''
    Monitors the Carla scene and actively removes the agents that have
    wondered too far away from the traffic circle in Town03.

    Parameters
    ----------
    actors : list
        A list of actors that have been spawned into the Carla world
    verbose : bool, optional
        Used to determine whether some information should be displayed.
    '''
    circle_center = carla.Location(0, 0, 0) # map/circle center
    dist_range = 100.0 # 100 meters from traffic circle center
    actor_list = world.get_actors()
    vehicle_list = actor_list.filter("*vehicle*")

    for vehicle in vehicle_list:
        dist_from_origin = vehicle.get_location().distance(circle_center)
        
        if dist_from_origin > dist_range or vehicle.get_location().x<-60:
            vehicle.destroy()

##########
# Event 4 Map Setting
##########


def in_roundabout(ego_x,ego_y,r_thres = 27):

    cx = -0.4771
    cy = 0.1983

    d_to_center = np.sqrt(cx*cx+cy*cy)

    if d_to_center > r_thres:
        return False
    
    return True

def build_lane(r,lane_index,ego_x,ego_y):
    lane = Lane()
    cx = -0.4771
    cy = 0.1983
    lane.length = 2*np.pi*r
    lane.index = lane_index
    ego_vehicle_angle =np.arctan2(ego_y-cy,ego_x-cx)

    for angle in (ego_vehicle_angle+np.linspace(-np.pi,np.pi,1000)):
        point = LanePoint()
        point.position.x = cx + r*np.cos(angle)
        point.position.y = cy + r*np.sin(angle)
        point.tangent = angle + np.pi/2
        point.tangent = (point.tangent + np.pi)%(2*np.pi)-np.pi
        point.width = 3.7
        lane.central_path_points.append(point)

    return lane


def build_multilane_map(ego_x,ego_y,target_lane_index):

    static_map = Map()
    static_map.in_junction = False
    static_map.target_lane_index = target_lane_index
    lane_inside = build_lane(19.8,1,ego_x,ego_y)
    lane_outside = build_lane(23.5,0,ego_x,ego_y)
    static_map.lanes.append(lane_outside)
    static_map.lanes.append(lane_inside)

    return static_map

def build_reference_path(ego_x,ego_y,ReferencePathGenerator,publisher_reference_lane):

    current_route = ReferencePathGenerator.current_route
    if current_route is None:
        goal_x = -18.1677
        goal_y = 9.4515
        ReferencePathGenerator.calculate_route(ego_x,-ego_y,goal_x,goal_y)
        msg = ReferencePathGenerator.publish_waypoints()
        publisher_reference_lane.publish(msg)
        
global published_exit_path

def build_exit_map(ego_x,ego_y,ReferencePathGenerator,publisher_reference_lane,ready_to_exit):
    
    global published_exit_path
    if ready_to_exit or published_exit_path:
        static_map = Map()
        static_map.in_junction = True
        goal_x = 42.6482
        goal_y = -7.8439
        if not published_exit_path:
            ReferencePathGenerator.calculate_route(ego_x,-ego_y,goal_x,goal_y)
            msg = ReferencePathGenerator.publish_waypoints()
            publisher_reference_lane.publish(msg)
            published_exit_path = True
    else:
        static_map = build_multilane_map(ego_x,ego_y,0)

    return static_map

def pose_callback(msg, args):

    publisher_map, publisher_reference_lane, ReferencePathGenerator, starting_time = args

    ego_x = msg.state.pose.pose.position.x
    ego_y = msg.state.pose.pose.position.y
    current_time = msg.header.stamp.to_sec()

    cx = -0.4771
    cy = 0.1983
    d_to_center = np.sqrt((ego_x-cx)*(ego_x-cx)+(ego_y-cy)*(ego_y-cy))
    ego_vehicle_angle = np.arctan2(ego_y-cy,ego_x-cx)

    if d_to_center > 22.5 and d_to_center< 24.5 and ego_vehicle_angle < -0.1*np.pi and ego_vehicle_angle > -0.2*np.pi:
        ready_to_exit = True
    else:
        ready_to_exit = False

    if current_time-starting_time < RUNNING_TIME:
        static_map = build_multilane_map(ego_x,ego_y,1)
        publisher_map.publish(static_map)
        build_reference_path(ego_x,ego_y,ReferencePathGenerator,publisher_reference_lane)
    else:
        static_map = build_exit_map(ego_x,ego_y,ReferencePathGenerator,publisher_reference_lane,ready_to_exit)
        publisher_map.publish(static_map)
    

def generate_traffic(carla_world,delay = 0.05):
    
    # generate surrounding vehicles
    blueprints = carla_world.get_blueprint_library().filter('vehicle.*')
    spawn_points = carla_world.get_map().get_spawn_points()
    while not rospy.is_shutdown():
        spawn_traffic_circle_agents(1000,carla_world,blueprints,spawn_points)
        remove_non_traffic_circle_agents(carla_world)
        time.sleep(delay)

if __name__ == "__main__":
    rospy.init_node("carla_challenge_setting_node")

    host = rospy.get_param("/carla/host", "127.0.0.1")
    port = rospy.get_param("/carla/port", 2000)
    carla_client = carla.Client(host=host, port=port)
    carla_client.set_timeout(2)
    carla_world = carla_client.get_world()
    rospy.loginfo("Connected to Carla.")
    ReferencePathGenerator = CarlaReferecePathGenerator(carla_world)
    global published_exit_path
    published_exit_path = False

    starting_time = rospy.Time.now().to_sec()
    _local_map_publisher = rospy.Publisher("/zzz/navigation/local_static_map", Map, queue_size=1)
    _reference_path_publisher = rospy.Publisher("/zzz/navigation/reference_path", Path, queue_size=1)
    _pose_subscriber = rospy.Subscriber("/zzz/navigation/ego_pose", RigidBodyStateStamped, pose_callback,
        (_local_map_publisher, _reference_path_publisher, ReferencePathGenerator, starting_time))

    # generate surrounding vehicles
    thread.start_new_thread(generate_traffic,(carla_world,0.05))

    rospy.spin()

    del ReferencePathGenerator
    del carla_world
    del carla_client
