#!/usr/bin/env python

import math
import random
import sys
import thread
import time

import numpy as np
import rospy
from nav_msgs.msg import Path

import carla
import tf
from std_msgs.msg import Header, Int16
from tf.transformations import euler_from_quaternion
from nav_msgs.msg import Path
from geometry_msgs.msg import PoseStamped
from carla_msgs.msg import CarlaWorldInfo
from carla import Location, Rotation, Transform, Vector3D
#from carla_waypoint_publisher import CarlaReferecePathGenerator
from carla_waypoint_publisher import CarlaToRosWaypointConverter
from zzz_driver_msgs.msg import RigidBodyStateStamped
from zzz_navigation_msgs.msg import Lane, LanePoint, Map, MapString
from geometry_msgs.msg import PoseWithCovarianceStamped, Pose
from carla_msgs.msg import CarlaCollisionEvent # FIXME: This is Carla related
from random import randint
from agents.navigation.global_route_planner import GlobalRoutePlanner
from agents.navigation.global_route_planner_dao import GlobalRoutePlannerDAO

##########
# Global Setting
##########

global stay
stay = 0
global collision_signal
collision_signal = False
global if_intersection
if_intersection = False
global if_write
if_write = False
global if_write_collision
if_write_collision = False
global has_set 
has_set = 0
global trajectory_state
trajectory_state = 0
global needed_generate
needed_generate = 0
global intersection_num
intersection_num = 0
global collision_num
collision_num = 0
global stuck_num
stuck_num = 0
global if_stuck
if_stuck = False

global first_goal
first_goal = Transform()

first_goal = Transform()
first_goal.location.x = 32
first_goal.location.y = -20
first_goal.location.z = 0
first_goal.rotation.pitch = 0
first_goal.rotation.yaw = 0 
first_goal.rotation.roll = 0

global second_goal
second_goal = Transform()
second_goal.location.x = -51.2
second_goal.location.y = -70.7
second_goal.location.z = 0
second_goal.rotation.pitch = 0
second_goal.rotation.yaw = 0 
second_goal.rotation.roll = 0

global first_start
first_start = Transform()
first_start.location.x = -10
first_start.location.y = -96
first_start.location.z = 0
first_start.rotation.pitch = 0
first_start.rotation.yaw = 180
first_start.rotation.roll = 0

global second_start
second_start = Transform()
second_start.location.x = -10
second_start.location.y = 6.5
second_start.location.z = 0
second_start.rotation.pitch = 0
second_start.rotation.yaw = 0
second_start.rotation.roll = 0

global circle_center
circle_center = carla.Location(-10, -43, 0) # map/circle center

global stopped_time
stopped_time = np.zeros(1000000)

def change_the_world(carla_world):
    weather = carla_world.get_weather()
    weather.cloudyness = 0
    weather.precipitation = 0
    weather.precipitation_deposits = 0
    weather.wind_intensity = 0
    weather.sun_azimuth_angle = 90
    weather.sun_altitude_angle = 90
    
    carla_world.set_weather(weather)

def change_traffic_lights(carla_world):
    traffic_lights = carla_world.get_actors().filter('*traffic_light*')
    for tl in traffic_lights:
        tl.set_green_time(5)
        tl.set_red_time(5)
        # tl.set_green_time(9.0)
        # tl.set_yellow_time(0.01)
        # tl.set_red_time(0.01)


##########
# Callback
##########


def collision_callback(msg):
    global collision_signal
    collision_signal = True

def local_static_map_callback(msg):
    #print("Now we enter local static map callback")
    global if_intersection
    if msg.in_junction:
        if_intersection = True
    else:
        if_intersection = False

#######
# Data Recording
#######

def record_vehicle_states(carla_world, delay):

    while not rospy.is_shutdown():
        global collision_signal

        actor_list = carla_world.get_actors()
        vehicle_list = actor_list.filter("*vehicle*")
        num_agents = len(vehicle_list)

        v_in_one = 0
        v_in_second = 0
        v_in_third = 0
        v_in_fourth = 0
        ego = 0
        collision = 0
        if pose_buffer is not None:
            ego_x = pose_buffer.state.pose.pose.position.x#ego_vehicle.get_location().x
            ego_y = pose_buffer.state.pose.pose.position.y#-ego_vehicle.get_location().y
            if -55.0 < ego_x < -40.0 and -10.0 < ego_y < 10.0:
                ego = 1
            elif -55.0 < ego_x < -40.0 and 80.0 < ego_y < 95.0:
                ego = 2
            elif 20.0 < ego_x < 40 and -10.0 < ego_y < 10.0:
                ego = 3
            elif 20.0 < ego_x < 40 and 80.0 < ego_y < 95.0:
                ego = 4
            elif -55.0 < ego_x < -40.0 or 20.0 < ego_x < 40:
                if -10.0 < ego_y < 10.0 or 80.0 < ego_y < 95.0:
                    if collision_signal:
                        collision = 1

        for vehicle in vehicle_list:
            location = vehicle.get_location()
            if -55.0 < location.x < -40.0 and -10.0 < location.y < 10.0:
                v_in_one = v_in_one + 1
            elif -55.0 < location.x < -40.0 and 80.0 < location.y < 95.0:
                v_in_second = v_in_second + 1
            elif 20.0 < location.x < 40 and -10.0 < location.y < 10.0:
                v_in_third = v_in_third + 1
            elif 20.0 < location.x < 40 and 80.0 < location.y < 95.0:
                v_in_fourth = v_in_fourth + 1
         
        fw = open("/home/carla/ZZZ/record_vehicle.txt", 'a')   
        fw.write(str(num_agents))   
        fw.write(",")   
        fw.write(str(v_in_one))   
        fw.write(",")   
        fw.write(str(v_in_second))   
        fw.write(",")   
        fw.write(str(v_in_third))   
        fw.write(",")   
        fw.write(str(v_in_fourth))   
        fw.write(",")   
        fw.write(str(ego))   
        fw.write(",")   
        fw.write(str(collision))   
        fw.write("\n")
        fw.close()
        time.sleep(delay)
            
def record_collsion_to_txt(ego_vehicle):
    # if in intersection
    global if_write
    global if_write_collision
    global stay
    global collision_signal
    global if_intersection
    global intersection_num #FIXME: read these nums from txt
    global collision_num
    global stuck_num
    global if_stuck
    
    if_intersection = False
    ego_x = ego_vehicle.get_location().x
    ego_y = -ego_vehicle.get_location().y
    if -55.0 < ego_x < -40.0 or 20.0 < ego_x < 40:
        if -10.0 < ego_y < 10.0 or 80.0 < ego_y < 95.0:
            if_intersection = True

    if not if_intersection:
        if_write = False
        if_write_collision = False
    
    if if_stuck == True:
        stuck_num = stuck_num + 1          
        print("Record To Txt: Stuck")
        if_stuck = False

    if if_intersection == True and if_write_collision == False:    
        if collision_signal and abs(ego_vehicle.get_velocity() > 0.02):
            collision_num = collision_num + 1
            print("Record To Txt: Collision")
            if_write_collision = True
    
    if if_intersection == True and if_write == False:
        intersection_num = intersection_num + 1
        print("Record To Txt: In intersection")
        if_write = True
    
        # Refresh num
        stuck_rate = float(stuck_num) / float(intersection_num)
        collision_rate = float(collision_num) / float(intersection_num)
        pass_rate = 1 - ((float(collision_num) + float(stuck_num)) / float(intersection_num))
        fw = open("/home/icv/zwt_rls/record_collision.txt", 'a')   
        # Write num
        fw.write(str(intersection_num)) 
        fw.write(", ")
        fw.write(str(stuck_num)) 
        fw.write(", ")
        fw.write(str(collision_num)) 
        fw.write(", ")
        fw.write(str(stuck_rate)) 
        fw.write(", ")
        fw.write(str(collision_rate)) 
        fw.write(", ")
        fw.write(str(pass_rate)) 
        fw.write("\n")
        fw.close()               
#########
# Ego vehicle related
#########

def adjust_ref_path(ego_x, ego_y):
    global trajectory_state
    # FIXME(zhcao): trajectory_state indicates if the trajectory is the first (1) or the second one (2).

    if math.pow((ego_x+7),2) + math.pow((ego_y+3),2) < 100:
        if trajectory_state != 2:              
            calculate_route(second_start, second_goal)
            trajectory_state = 2
        return
        
    if math.pow((ego_x+10),2) + math.pow((ego_y-90),2) < 100:
        if trajectory_state != 1:    
            calculate_route(first_start, first_goal)
            trajectory_state = 1
    return

def ego_vehicle_outside_world(ego_x, ego_y):

    x_max = 8000
    x_min = -9000
    y_max = 4000
    y_min = -12500

    if (ego_x-x_max)*(ego_x-x_min)<0 and (ego_y-y_max)*(ego_y-y_min)<0:
        return False

    return True

def stay_too_long(ego_v, stay_thres = 30):
    # FIXME(zhcao): use ego_vehicle directly
    
    global stay
    if ego_v < 0.1:
        pass
    else:
        stay = rospy.Time.now().to_sec()

    if stay > 0 and rospy.Time.now().to_sec() - stay > stay_thres:
        return True
    return False

def calculate_route(start, goal):
    rospy.loginfo("Calculating route to x={}, y={}, z={}".format(
            goal.location.x,
            goal.location.y,
            goal.location.z))

    grp = GlobalRoutePlanner(dao)
    grp.setup()
    current_route = grp.trace_route(carla.Location(start.location.x,
                                            start.location.y,
                                            start.location.z),
                            carla.Location(goal.location.x,
                                            goal.location.y,
                                               goal.location.z))

    msg = Path()
    msg.header.frame_id = "map"
    msg.header.stamp = rospy.Time.now()

    for wp in current_route:
        pose = PoseStamped()
        pose.pose.position.x = wp[0].transform.location.x
        pose.pose.position.y = -wp[0].transform.location.y
        pose.pose.position.z = wp[0].transform.location.z

        quaternion = tf.transformations.quaternion_from_euler(
            0, 0, -math.radians(wp[0].transform.rotation.yaw))
        pose.pose.orientation.x = quaternion[0]
        pose.pose.orientation.y = quaternion[1]
        pose.pose.orientation.z = quaternion[2]
        pose.pose.orientation.w = quaternion[3]
        msg.poses.append(pose)

    _waypoint_publisher.publish(msg)
    rospy.loginfo("Published {} waypoints.".format(len(msg.poses)))

def restart_ego_vehicle(ego_vehicle):
    global stay
    global collision_signal
    global trajectory_state
    global first_start
    global first_goal
    global if_stuck
    
    ego_loc = ego_vehicle.get_location()
    ego_vel = ego_vehicle.get_velocity()
    ego_x = ego_loc.x
    ego_y = ego_loc.y
    ego_v = math.sqrt(ego_vel.x**2 + ego_vel.y**2)

    restart = False

    if collision_signal:
        restart = True
        collision_signal = False
        print("----> Restart: Collision")

    if not restart and stay_too_long(ego_v):
        restart = True
        if_stuck = True
        print("----> Restart: Ego vehicle stucked")

    if not restart and ego_vehicle_outside_world(ego_x, ego_y):
        restart = True
        print("----> Restart: Ego vehicle out of range")
    time.sleep(0.5)

    if restart is True:
        stay = rospy.Time.now().to_sec()
        # ego_vehicle.set_velocity(carla.Vector3D())
        ego_vehicle.set_transform(first_start)
        trajectory_state = 1

        calculate_route(first_start, first_goal)
        print("Restarting....")
    
    time.sleep(0.5)
    _restart_publisher.publish(restart)
    
    return

if __name__ == "__main__":
    rospy.init_node("intersection_env")

    host = rospy.get_param("/carla/host", "127.0.0.1")
    port = rospy.get_param("/carla/port", 2000)
    carla_client = carla.Client(host=host, port=port)
    carla_client.set_timeout(10.0)
    carla_world = carla_client.get_world()
    
    rospy.loginfo("Connected to Carla.")
    needed_generate = rospy.Time.now().to_sec()


    # Publish and Subscribe messages
    _local_map_subscriber = rospy.Subscriber("/zzz/navigation/local_static_map", Map, local_static_map_callback)
    _reference_path_publisher = rospy.Publisher("/carla/ego_vehicle/waypoints", Path, queue_size=1, latch=True)
    _collision_subscriber = rospy.Subscriber("/carla/ego_vehicle/collision", CarlaCollisionEvent, collision_callback)
    role_name = rospy.get_param("~role_name", 'ego_vehicle')
    _waypoint_publisher = rospy.Publisher('carla/{}/waypoints'.format(role_name), Path, queue_size=1, latch=True)
    _restart_publisher = rospy.Publisher("/carla/ego_vehicle/restart", Int16, queue_size=1, latch=True)

    # Change traffic lights
    change_traffic_lights(carla_world)
   
    rate = rospy.Rate(20)

    # Generate Reference Path
    dao = GlobalRoutePlannerDAO(carla_world.get_map(), 1)
    calculate_route(first_start, first_goal)
    trajectory_state = 1
    
    count = 0
    ego_vehicle = None
    while ego_vehicle is None:

        actor_list = carla_world.get_actors()
        vehicle_list = actor_list.filter("*vehicle*")
        for vehicle in vehicle_list:
            if vehicle.attributes['role_name'] == "ego_vehicle":
                ego_vehicle = vehicle
                break

    while not rospy.is_shutdown():

        ego_loc = ego_vehicle.get_location()
        
        # Record txt (must before restart)
        record_collsion_to_txt(ego_vehicle)

        # Restart ego when needed
        restart_ego_vehicle(ego_vehicle)

        adjust_ref_path(ego_loc.x, -ego_loc.y) # FIXME(zhcao)

        time.sleep(0.05)
        # rate.sleep()


    del carla_world
    del carla_client
